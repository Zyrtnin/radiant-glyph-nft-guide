<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radiant Glyph NFT - Documentation Test</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 40px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .warning {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 30px;
        }

        .warning-title {
            font-weight: bold;
            color: #856404;
            margin-bottom: 8px;
        }

        .success {
            background: #d4edda;
            border: 2px solid #c3e6cb;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            color: #155724;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        input[type="text"],
        input[type="file"],
        textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus,
        textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        textarea {
            resize: vertical;
            min-height: 60px;
            font-family: inherit;
        }

        .image-preview {
            margin-top: 15px;
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            min-height: 150px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .image-preview img {
            max-width: 100%;
            max-height: 300px;
            border-radius: 8px;
        }

        .image-preview.empty {
            color: #999;
        }

        .button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 100%;
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            display: none;
        }

        .status.info {
            background: #d1ecf1;
            border: 2px solid #bee5eb;
            color: #0c5460;
        }

        .status.success {
            background: #d4edda;
            border: 2px solid #c3e6cb;
            color: #155724;
        }

        .status.error {
            background: #f8d7da;
            border: 2px solid #f5c6cb;
            color: #721c24;
        }

        .status.show {
            display: block;
        }

        .code-block {
            background: #f4f4f4;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .section {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
        }

        .section h3 {
            color: #333;
            margin-bottom: 10px;
        }

        code {
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }

        .step {
            margin: 10px 0;
            padding: 10px;
            background: white;
            border-left: 4px solid #667eea;
        }

        .step-complete {
            border-left-color: #28a745;
        }

        .step-error {
            border-left-color: #dc3545;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Radiant Glyph NFT - Documentation Test</h1>
        <p class="subtitle">Testing the implementation guide - Goes through all steps EXCEPT final broadcast</p>

        <div class="warning">
            <div class="warning-title">Test Mode - No Broadcasting</div>
            This implementation follows the guide exactly and will:
            <ol style="margin-left: 20px; margin-top: 10px;">
                <li>Create and encode CBOR glyph data (with thumbnail)</li>
                <li>Build commit transaction hex</li>
                <li>Build reveal transaction hex</li>
                <li><strong>STOP before broadcasting</strong> (shows signed hex for verification)</li>
            </ol>
        </div>

        <div class="success">
            <strong>CBOR Library Status:</strong> <span id="cborStatus">Checking...</span>
        </div>

        <form id="mintForm">
            <div class="form-group">
                <label for="nftName">NFT Name *</label>
                <input type="text" id="nftName" placeholder="My Amazing NFT #1" required value="Test NFT from Guide">
            </div>

            <div class="form-group">
                <label for="nftAttrs">Custom Attributes (JSON)</label>
                <textarea id="nftAttrs" placeholder='{"artist": "Your Name", "score": 1000000}'>{"test": true, "source": "documentation_guide"}</textarea>
            </div>

            <div class="form-group">
                <label for="imageUpload">Select Image *</label>
                <input type="file" id="imageUpload" accept="image/*" required>
                <div style="font-size: 12px; color: #666; margin-top: 5px;">
                    Will be resized to 225px WebP @ 90% quality (~20-25KB)
                </div>
                <div id="imagePreview" class="image-preview empty">
                    No image selected
                </div>
            </div>

            <button type="submit" class="button" id="mintButton">
                Build NFT Transactions (Test Mode)
            </button>
        </form>

        <div id="status" class="status"></div>

        <div id="results" style="display: none;">
            <div class="section">
                <h3>Transaction Details</h3>
                <div id="transactionSteps"></div>
            </div>

            <div class="section">
                <h3>Verification Data</h3>
                <div id="verificationData"></div>
            </div>
        </div>
    </div>

    <!-- CBOR Library - MUST LOAD FIRST (per documentation) -->
    <!-- Download from: https://raw.githubusercontent.com/paroga/cbor-js/master/cbor.js -->
    <script src="js/cbor.min.js"></script>

    <script>
        // =====================================================================
        // IMPLEMENTATION BASED SOLELY ON DOCUMENTATION GUIDE
        // https://github.com/user/radiant-glyph-nft-guide
        // =====================================================================

        // Check CBOR library (Critical Requirement #1 from docs)
        function checkCBORLibrary() {
            const statusEl = document.getElementById('cborStatus');
            if (typeof CBOR === 'undefined') {
                statusEl.textContent = 'NOT LOADED - NFTs would be unreadable!';
                statusEl.style.color = '#dc3545';
                document.getElementById('mintButton').disabled = true;
                return false;
            } else {
                statusEl.textContent = 'Loaded correctly';
                statusEl.style.color = '#28a745';
                return true;
            }
        }

        window.addEventListener('DOMContentLoaded', () => {
            setTimeout(checkCBORLibrary, 500);
        });

        // Image preview
        document.getElementById('imageUpload').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const preview = document.getElementById('imagePreview');
                    preview.innerHTML = `<img src="${e.target.result}" alt="Preview">`;
                    preview.classList.remove('empty');
                };
                reader.readAsDataURL(file);
            }
        });

        // =====================================================================
        // STEP 1: Create Thumbnail (from documentation section "On-Chain Images")
        // =====================================================================
        async function createThumbnail(dataUrl, maxSize = 225, quality = 0.90) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    // Calculate dimensions maintaining aspect ratio
                    let width = img.width;
                    let height = img.height;

                    if (width > height) {
                        if (width > maxSize) {
                            height = Math.round((height * maxSize) / width);
                            width = maxSize;
                        }
                    } else {
                        if (height > maxSize) {
                            width = Math.round((width * maxSize) / height);
                            height = maxSize;
                        }
                    }

                    // Create canvas and draw scaled image
                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    ctx.drawImage(img, 0, 0, width, height);

                    // Convert to WebP for best quality/size ratio
                    canvas.toBlob((blob) => {
                        const reader = new FileReader();
                        reader.onload = () => {
                            const uint8Array = new Uint8Array(reader.result);
                            console.log(`Thumbnail: ${width}x${height}, ${uint8Array.length} bytes (WebP @ ${quality * 100}%)`);
                            resolve(uint8Array);
                        };
                        reader.onerror = reject;
                        reader.readAsArrayBuffer(blob);
                    }, 'image/webp', quality);
                };
                img.onerror = reject;
                img.src = dataUrl;
            });
        }

        // =====================================================================
        // STEP 2: Encode Glyph Data (from documentation "CBOR Payload Format")
        // =====================================================================
        function encodeGlyphData(data) {
            if (typeof CBOR === 'undefined') {
                throw new Error('CBOR library not loaded! NFT would be unreadable.');
            }

            // Ensure protocol is set (Critical Requirement from docs)
            if (!data.p) {
                data.p = [2]; // Protocol: 2 = NFT
            }

            // Encode to CBOR
            const marker = new TextEncoder().encode('gly');
            const cborData = CBOR.encode(data);
            const payload = new Uint8Array(cborData);

            // Combine marker and payload (Glyph = "gly" + CBOR)
            const result = new Uint8Array(marker.length + payload.length);
            result.set(marker, 0);
            result.set(payload, marker.length);

            return result;
        }

        // =====================================================================
        // STEP 3: Calculate Payload Hash (from "Commit Transaction" section)
        // =====================================================================
        async function calculatePayloadHash(glyphHex) {
            // Skip "gly" marker (first 6 hex chars)
            const cborHex = glyphHex.substring(6);
            const cborBytes = hexToBytes(cborHex);

            // Double SHA256
            const hash1 = await crypto.subtle.digest('SHA-256', cborBytes);
            const hash2 = await crypto.subtle.digest('SHA-256', hash1);

            return bytesToHex(new Uint8Array(hash2));
        }

        // =====================================================================
        // STEP 4: Build nftCommitScript (from "Commit Transaction" section)
        // =====================================================================
        function buildNftCommitScript(pubkeyhash, payloadHash) {
            const OP_HASH256 = 'aa';
            const OP_EQUALVERIFY = '88';
            const OP_DUP = '76';
            const OP_HASH160 = 'a9';
            const OP_CHECKSIG = 'ac';
            const OP_INPUTINDEX = 'c0';
            const OP_OUTPOINTTXHASH = 'c8';
            const OP_OUTPOINTINDEX = 'c9';
            const OP_4 = '54';
            const OP_NUM2BIN = '80';
            const OP_CAT = '7e';
            const OP_REFTYPE_OUTPUT = 'da';
            const OP_2 = '52';
            const OP_NUMEQUALVERIFY = '9d';

            const glyphMarker = '676c79';  // "gly" in hex

            let script = OP_HASH256;
            script += '20' + payloadHash;
            script += OP_EQUALVERIFY;
            script += '03' + glyphMarker;
            script += OP_EQUALVERIFY;
            script += OP_INPUTINDEX + OP_OUTPOINTTXHASH;
            script += OP_INPUTINDEX + OP_OUTPOINTINDEX;
            script += OP_4 + OP_NUM2BIN + OP_CAT;
            script += OP_REFTYPE_OUTPUT + OP_2 + OP_NUMEQUALVERIFY;
            script += OP_DUP + OP_HASH160;
            script += '14' + pubkeyhash;
            script += OP_EQUALVERIFY + OP_CHECKSIG;

            return script;
        }

        // =====================================================================
        // STEP 5: Build Singleton Script (from "Reveal Transaction" section)
        // =====================================================================
        function buildSingletonScript(commitTxid, commitVout, ownerPubkeyhash) {
            // Reverse txid (stored little-endian)
            const txidBytes = [];
            for (let i = 0; i < 64; i += 2) {
                txidBytes.unshift(commitTxid.substr(i, 2));
            }
            const txidReversed = txidBytes.join('');

            // Vout as 4-byte little-endian
            const voutHex = commitVout.toString(16).padStart(8, '0');
            const voutLE = voutHex.match(/.{2}/g).reverse().join('');

            const ref = txidReversed + voutLE;

            // d8 + ref + 75 (OP_DROP) + 76a914 + pubkeyhash + 88ac
            const script = 'd8' + ref + '7576a914' + ownerPubkeyhash + '88ac';

            return { script, ref };
        }

        // =====================================================================
        // Helper Functions
        // =====================================================================
        function hexToBytes(hex) {
            const bytes = new Uint8Array(hex.length / 2);
            for (let i = 0; i < hex.length; i += 2) {
                bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
            }
            return bytes;
        }

        function bytesToHex(bytes) {
            return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
        }

        function showStatus(type, message) {
            const statusDiv = document.getElementById('status');
            statusDiv.className = `status ${type} show`;
            statusDiv.innerHTML = message;
        }

        function addStep(message, complete = false, error = false) {
            const stepsDiv = document.getElementById('transactionSteps');
            const step = document.createElement('div');
            step.className = 'step';
            if (complete) step.classList.add('step-complete');
            if (error) step.classList.add('step-error');
            step.textContent = message;
            stepsDiv.appendChild(step);
        }

        // =====================================================================
        // MAIN FORM HANDLER
        // =====================================================================
        document.getElementById('mintForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            if (!checkCBORLibrary()) {
                return;
            }

            const mintButton = document.getElementById('mintButton');
            mintButton.disabled = true;
            mintButton.textContent = 'Processing...';

            document.getElementById('results').style.display = 'block';
            document.getElementById('transactionSteps').innerHTML = '';
            document.getElementById('verificationData').innerHTML = '';

            try {
                // Get form data
                const name = document.getElementById('nftName').value;
                const imageFile = document.getElementById('imageUpload').files[0];

                // Parse attributes
                let attrs = {};
                const attrsText = document.getElementById('nftAttrs').value.trim();
                if (attrsText) {
                    try {
                        attrs = JSON.parse(attrsText);
                    } catch (err) {
                        throw new Error('Invalid JSON in attributes field');
                    }
                }

                addStep('Reading image file...');
                const imageDataUrl = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(imageFile);
                });

                // STEP 1: Create thumbnail (Critical Requirement #2)
                addStep('Creating thumbnail (225px WebP @ 90%)...', true);
                const thumbnail = await createThumbnail(imageDataUrl, 225, 0.90);

                // STEP 2: Build payload with main field (Critical Requirement #2)
                addStep('Building Glyph payload with on-chain image...', true);
                const payload = {
                    p: [2], // NFT protocol
                    name: name,
                    type: 'photo',
                    main: {
                        t: 'image/webp',
                        b: thumbnail
                    },
                    attrs: attrs
                };

                // STEP 3: Encode with CBOR (Critical Requirement #1)
                addStep('Encoding with CBOR (mandatory for Glyph wallets)...', true);
                const glyphData = encodeGlyphData(payload);
                const glyphHex = bytesToHex(glyphData);

                // STEP 4: Calculate payload hash
                addStep('Calculating payload hash (double SHA256)...', true);
                const payloadHash = await calculatePayloadHash(glyphHex);

                // STEP 5: Build commit script
                addStep('Building nftCommitScript...', true);
                // Using a mock pubkeyhash - in real implementation this comes from your wallet
                const mockPubkeyhash = '89abcdef01234567890123456789012345678901';
                const commitScript = buildNftCommitScript(mockPubkeyhash, payloadHash);

                // STEP 6: Build singleton script
                addStep('Building singleton ref output script...', true);
                // Using mock commit txid - in real implementation this comes from broadcast commit
                const mockCommitTxid = '0'.repeat(64);
                const mockCommitVout = 0;
                const singletonResult = buildSingletonScript(mockCommitTxid, mockCommitVout, mockPubkeyhash);

                addStep('All transaction data prepared successfully!', true);

                // Display verification data
                const verificationHtml = `
                    <div style="margin-bottom: 20px;">
                        <strong>Glyph Data:</strong>
                        <div class="code-block">${glyphHex.substring(0, 200)}... (${glyphData.length} bytes total)</div>
                    </div>
                    <div style="margin-bottom: 20px;">
                        <strong>Payload Hash (for commit script):</strong>
                        <div class="code-block">${payloadHash}</div>
                    </div>
                    <div style="margin-bottom: 20px;">
                        <strong>nftCommitScript:</strong>
                        <div class="code-block">${commitScript.substring(0, 200)}... (${commitScript.length / 2} bytes)</div>
                    </div>
                    <div style="margin-bottom: 20px;">
                        <strong>Singleton Ref:</strong>
                        <div class="code-block">${singletonResult.ref}</div>
                    </div>
                    <div style="margin-bottom: 20px;">
                        <strong>Singleton Output Script:</strong>
                        <div class="code-block">${singletonResult.script.substring(0, 200)}...</div>
                    </div>
                    <div style="margin-bottom: 20px;">
                        <strong>Thumbnail Size:</strong> ${thumbnail.length} bytes (${(thumbnail.length / 1024).toFixed(2)} KB)<br>
                        <strong>Total Glyph Data:</strong> ${glyphData.length} bytes (${(glyphData.length / 1024).toFixed(2)} KB)<br>
                        <strong>Estimated Cost:</strong> ~${(glyphData.length * 0.000015).toFixed(4)} RXD
                    </div>
                `;
                document.getElementById('verificationData').innerHTML = verificationHtml;

                showStatus('success', `
                    <strong>Documentation Test: PASSED</strong><br><br>
                    All transaction components built successfully using only the documentation guide!<br><br>
                    <strong>What was created:</strong><br>
                    - CBOR-encoded glyph data (${glyphData.length} bytes)<br>
                    - nftCommitScript with payload validation<br>
                    - Singleton ref output script<br>
                    - On-chain thumbnail (${thumbnail.length} bytes WebP)<br><br>
                    <strong>To complete minting, you would need:</strong><br>
                    1. Radiant node RPC access to create/sign/broadcast transactions<br>
                    2. Wallet with sufficient RXD balance (~${(glyphData.length * 0.000015 + 0.01).toFixed(4)} RXD)<br>
                    3. Node.js signing script with radiantjs library<br><br>
                    <strong>Next steps:</strong> See "Complete Implementation Example" section in the guide.
                `);

            } catch (error) {
                console.error('Error:', error);
                addStep('Error: ' + error.message, false, true);
                showStatus('error', `Error: ${error.message}`);
            } finally {
                mintButton.disabled = false;
                mintButton.textContent = 'Build NFT Transactions (Test Mode)';
            }
        });
    </script>
</body>
</html>
